# 线程实现模型
线程的实现模型主要有3个，分别为：
- 用户级线程模型
- 内核级线程模型
- 两级线程模型

三者之间的差异在于用户线程与内核调度实体(KSE)之间的对应关系上。
内核调度实体(Kernel Scheduling Entity, KSE)就是可以被操作系统内核调度器调度的对象，
也称为内核级线程，是操作系统内核的最小调度单元。

## 用户级线程模型
![用户级线程模型](../pic/线程模型-用户级线程模型.svg)
用户线程与KSE为多对一(N:1)的映射关系。此模型下的线程由用户级别的线程库全权管理，线程库存储在进程的用户空间中，
这些线程的存在对于内核来说是无法感知的，所以这些线程也不是内核调度器调度的对象。一个进程中所有创建的线程都只和同一个KSE在运行时动态绑定，
内核的所有调度都是基于用户进程的。对于线程的调度则是在用户层面完成的，相较于内核调度不需要让CPU在用户态和内核态之间进行切换，
这种实现方式相比内核级线程模型可以做的很轻量级，对系统资源消耗会小很多，上下文切换花费的代价也会小很多。许多语言实现的协程库基本上都属于这种方式。
但是，此模型下的多线程并不能真正的并发运行。例如：如果某个线程在I/O操作过程中被阻塞，那么其所属进程内的所有线程都被阻塞，整个进程将被挂起。

![内核级线程模型](../pic/线程模型-内核级线程模型.svg)
用户线程与KSE为一对一(1:1)的映射关系。此模型下的线程由内核负责管理，应用程序对线程创建、终止和同步都必须通过内核提供的系统调用来完成，
内核可以分别对每一个线程进行调度。所以，一对一线程模型可以真正的实现线程的并发运营，大部分语言实现的线程库基本上都属于这种方式。但是，
此模型下线程的创建、切换和同步都需要花费更多的内核资源和时间，如果一个进程包含了大量的线程，那么它会给内核的调度器造成非常大的负担，
甚至会影响到操作系统的整体性能。

![两级线程模型](../pic/线程模型-两级线程模型.svg)
用户线程与KSE为多对多(N:M)的映射关系。两级线程模型吸收前两种线程模型的优点并且尽量规避了它们缺点，区别于用户级线程模型，
两级线程模型中的进程可以与多个内核线程KSE关联，也就是说一个进程内的多个线程可以分别绑定一个自己的KSE,这点和内核级线程模型相似；
其次，又区别于内核级线程模型，它的进程里的线程并不与KSE绑定运行。所以，两级线程模型既不是用户级线程模型那种完全靠自己调度的
也不是内核级线程模型完全靠操作系统调度的，而是一种自身调度与系统调度协同工作的中间态，即用户调度器实现用户线程到KSE的调度，
内核调度器实现KSE到CPU上的调度。
